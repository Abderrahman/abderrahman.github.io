<!DOCTYPE html>
<html>
<title>BlueApp</title>
<style type="text/css">
	span.str{color : #000;}
</style>
<!-- Begin Inspectlet Embed Code -->
	<script type="text/javascript" id="inspectletjs">
	window.__insp = window.__insp || [];
	__insp.push(['wid', 1320308602]);
	(function() {
	function ldinsp(){var insp = document.createElement('script'); insp.type = 'text/javascript'; insp.async = true; insp.id = "inspsync"; insp.src = ('https:' == document.location.protocol ? 'https' : 'http') + '://cdn.inspectlet.com/inspectlet.js'; var x = document.getElementsByTagName('script')[0]; x.parentNode.insertBefore(insp, x); };
	document.readyState != "complete" ? (window.attachEvent ? window.attachEvent('onload', ldinsp) : window.addEventListener('load', ldinsp, false)) : ldinsp();
	
	})();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-67511858-1', 'auto');
  ga('send', 'pageview');

</script>
<xmp theme="united" style="display:none;">

## Useful Resources
- [Baeldung.com](https://www.baeldung.com/java-8-interview-questions)
- [Spring.io](https://spring.io/guides/gs/consuming-rest-angularjs/)


## Foundations of Programming ~ Design Patterns
	- This course offers a look inside the 7 most used design patterns, starting with "Strategy" using a duck example to illustrate this design pattern.
	- In Strategy, it's better to favor composition over inheritage (which is one the design principles) in order to have control over each duck behavior (ex: fly behavior & quack behavior).
	- In Obsever, we see a solution that has been designed for a specific problem: When having an Observable (WeatherData) who needs to notify its observers (Forecast, Statistics ..)  with the last updates.
	- In Decorator, we used the coffee expl, milk, mocha, soy... And we saw that this same DP is used in the InputStream and BufferedInputStream buf = new BufferedInputStream(new FileInputStream("a.txt"));
	- In Singleton, to solve the "two threads accessing the getInstance at the same time" add the "synchronized" keyword in the function declaration. "public synchronized void getInstance".
	- The State design pattern look almost the same as Strategy DP in the class diagram, but it's used for a different purposes. This example was illustrated using the Gumball Machine.
	- And finally, the Iterator DP used with Collections. It's principle is that we don't need to know an object content, we only need a method to iterate over it's elements. (+ Factory the last DP)

 
## Foundations of Programming - Test-Driven Development	
	1 - Introduction to Test-Driven Development (TDD)
		TDD isn't about Stress testing (number of users using the app before crashing), performance testing, beta testing, integration testing or acceptance testing, it's about using automated unit tests.
		TDD "does development backwards" by writing detailed test cases first to validate the story's requirements are satisfied, and then writing the code focused on ensuring each test case passes.
		TDD is for a day to day, minute to minute programming... if you're programming you need to write your own unit tests, you can't use your testers for this kind of situation.
		TDD is an Agile development technique, just as Pair Programming, Refactoring and Continuous Integration.
	2 - Getting Started
		- Unit Testing Frameworks: JUnit (Java), NUnit (.NET), PyUnit (Python), CppUnit (C++). All of these are based on xUnit.
		TestNG is a testing framework for Java inspired by JUnit and NUnit. It's design goal is to cover a wider range of test categories: unit, functional, end-to-end, integration, etc.
		- To assert: is to state something to be true. It's not asking questions, not inviting an opinion, it's simply stating something to be true.
		Example: 1) To assert something positively: "I assert there's only 30 days in april". 2) Or to assert something isn't true: I assert the book x wasn't written by the author y.
		- JUnit is a part of the java library. You can run assert commands anywhere in your code. For example the command [void assertSame(obj1, obj2)] asserts that obj1 & obj2 are references to the same object.
	3 - Working with Tests
		TDD Process: Red/Green/Refactor - repeat. Annotations: in java: @Test, in DOT NET: [TestMethod] and [TestClass]
		The benefit of having these unit tests is to easily see the impact from refactoring that you weren't immediatly visioning. So just having these tests and being able to run them all the time is very useful.
		Naming: - For the unit test class we take the name of the class we're testing + the word "Test". Example: UserTest, BankAccountTest... and sometimes "UserTestCase" or "UserTests". 
		- For Functions: "test" + the name of the function. Example: testWithDraw (some languages require 'test').
	4 - Individual Techniques
		- Testing expected exceptions: we add this extra code: @Test(expected=IllegalArgumentException.class) that tells JUnit if any code in this test method throws this specific exception we will go green bar.
		- Setting up and tearing down: @Before public void setUp() method is called before each test and @After public void tearDown() method is called after each test. So JUnit will call setUp before every single test method and tearDown after every single method. Reminder: your test methods should be completely independent of each other. @BeforeClass void setUpBeforeClass() (self-explanatory).
		- Common Questions: Do I test private methods? Generally, no. Typically, just make a test for a public method that proves the private method works.
		- Unit tests are not intended to test The Application - only the individual units of code, in isolation.
	5 - Additional Topics
		Typical reasons for *Mock Objects*:
		- Real object hasn't been written yet
		- External resource: file system, databases, network, printer
		optional: mock object can be told to expect a certain value. mockObj.expectZip(85645);
		Fake objects (dummy objects) are the simplest kind of mock objects they return pre-arranged results.
		Mock Object Framework: JMock, easyMock, mockito (Java).
		*Code Coverage* is typical for Enterprise Heavy Environment such as Java & .NET. Examples of code coverage tools: Emma, Clover by Attlasian (Java), dotCover and NCover (.NET)
	6 - Conclusion
		Behavior Driven Development: RSpec (Ruby) - Cucumber (Java).


## Fundamentals of Software Version Control
	01. Overview of Software Version Control
		How do teams benefit from version control?
			- synchronization -- easy to keep team members always up-to-date
			- accountability -- know who made each change and why
			- conflict detection -- keep the build clean every time
		Label significant changes: labels/tags
		-----------------------------------------
		Check-in = commit (cp changes from working set to repo)
		|----------------------------------------
		|	Check-in 2 lines version:
		|		git add program.c
		|		git commit -m "Add Func1()"
		|	or 1 line version:
		|		git commit -am "Add Func1()"
		|----------------------------------------
		Check-out = update (cp changes from repository to working set)
		|----------------------------------------
		|	git checkout (HEAD) myprog.c (cp changes from repository to working set) - HEAD means rollback to most recent commit and it's optional
		|	git checkout 87b53 myprog.c - means rollback to a typical revision/commit
		|----------------------------------------
		Others
		|----------------------------------------
		|	git log -p
		|	git log --oneline --all
		|----------------------------------------
		|	git diff
		|	git diff x y
		|	git diff HEAD (diff between repo and working set) if we commit the working set, then the working set becomes repo
		|----------------------------------------
		Revert/Rollback = overwrite files in your working set with specific version
		|----------------------------------------
		| git revert ... ?
		|----------------------------------------
	02. Background of Software Version Control
		- Centralized: CVS (1986), Perforce (1995), Subversion (2000), Microsoft Team Foundation Server (2010). In centralized version control we only have [Remote Repo (check-in, check-out) <-- working set]
		- Ditributed: Git (2005), Mercuarial (2005). In distributed version control we have [Remote Repo (push, pull) <-- Local repo (add, revert) <-- working set]
		Ditributed repository only:
			- push/export - send changes from one repo to another
			- pull/ import - update your working set with updates
		- branch/fork - make a clone of a repo
		- merge - integrate your branch (clone) back into the original repo
		- reverse integration/forward integration: branching by features
	03. Version Control Concepts
		Workflow integration: check-in -> build (unit test is Green = Build cleanly) -> commit to repository
		The foor different ways that you can use to interact with your version control software: 1) Command lines, 2) Standalone GUI Tools (github), 3) IDE Integration
		and 4) Shell Intergration: allows you to add Context menu to the windows explorer. Example: TortoiseGit, TortoiseSvn, TortoiseHg..
		Branch # Merge, Create Branch:
		|----------------------------------------
		| git branch not-master
		| git branch (to display the current branch)
		| git checkout not-master (change branch to not-master)
		| git merge not-master
		|----------------------------------------
		Tagging, Create Tag, show:
		|----------------------------------------
		| git tag -a v1 -m "Label Version 1"
		| git tag (to display the current tag)
		| git show v1 (to see the specific changes in this tag)
		| git checkout v1
		|----------------------------------------
	04. Subversion
		SVN can be used with microsoft's CodePlex which is free for hosting open source projects
	05. Perforce
	06. Microsoft Team Foundation Server (TFS)
	07. Git (The most important in my case)
	Take a clone of a remote repository and run git branch -a (to show all the branches git knows about). It will probably look something like this:
		|----------------------------------------
		|* master
		|remotes/origin/HEAD -> origin/master
		|remotes/origin/master
		|----------------------------------------
		- Here, **master** is a branch in the local repository. 
		- remotes/origin/master is a branch named **master** on the remote named **origin**. You can also refer to it as origin/master
		- remotes/origin/HEAD is the default branch for the remote named **origin**. This lets you simply say origin instead of origin/master.
	08. Mercurial
		cmd> hg --version
		most command are similar to gits
	Conclusion

## Mastering Github
	LEVEL 1
		Different Levels of Configuration
			--local : to set config for a single repo
			--global : to set config for your user
			--system : to set config for all users
		Examples: set local email if using a different (personal) github account other then the one used for your company
			$ git config --local user.email ab.hbabi@gmail.com
		List all your global configurations:
			$ git config --global --list
		Some useful configurations:
			$ git config --global push.defaults simple (push the current branch up to github)
		Default all new branches to fetch then rebase
			$ git config --global pull.rebase true (git pull = git fetch + git merge && git pull --rebase = git fetch + git rebase)
		Aliases
			$ git config --global alias.s "status -s"
			$ git config --global alias.lg "log --oneline --decorate --all  --graph"
		Section 2: forking and cloning
		Section 3: Submitting a pull request
		Section 4: Updating your fork
			$ git remote add upstream <path_to_repo>


## Maven Fundamentals
	1. Introduction to Maven Fundamentals
		What is Maven
			- Maven is a build tool, just as ant, make, a custom written bash file... used to build source code and produce an artifact. Maven always produces an artifact for example a jar or a war or a zip file.
			- It helps manage dependencies inside an app just as bower, composer, npm... Like when u want to use a tool like hibernate, there's one hibernate tool you need to import but it has 13 or 14 other librairies that it needs.
			- It handles versioning and releases and can easily produce Javadocs.
		Why do you wanna use it
			- Transitive dependencies: Downloading a dependency with also pull other items it needs.
			- The preferred choice for working with build tools like Jenkins
		Ant VS. Maven
			- Ant was developed to replace a build too called Make. It isn't a build tool as much as it is a scripting tool. You have to explicitly do everything in Ant.
			- Maven is a full fledged build tool. A lot of implicit functionality, transitive dependencies, built around versioning, convention over configuration, 
			**Ant** build.xml
			<project>
				<target name="clean">
					<delete dir="build" />
				</target>
				<target name="compile">
					<mkdir dir="build/classes" />
					<javac srcdir="src" destdir="build/classes" />
				</target>
				<target name="jar">
					...
				</target>
				<target name="run">
					...
				</target>
			</project>
			
			**Maven** pom.xml
			In this app I can do clean, compile, jar, run and it will all work because it knows from this pom file (it's what we call blackbox):
			<project xmlns="">
				<modelVersion>4.0.0</modelVersion>
				<groupId>com.mycompany</groupId>
				<artifactId>HelloWorld</artifactId>
				<version>0.0.1-SNAPSHOT</version>
			</project
		Summary
			- Ant is very declarative
			- Maven follows convention over configuration model meaning: that if I follow their naming convention, things are just gonna go easier for me.
			- Ant is maybe easier to learn, but it really is only beneficial as a scripting tool
			- Maven is really centered around managing your entire project's lifecycle (versions, how we structure code...)
		Demo - Hello World
			pom.xml tags
				- groupId is what differentiate us from other companies (com.pluralsight)
				- artifactId is what we want to name our application (HelloWord)
				- version (1.0-SNAPSHOT)
				- modelVersion is the version of the xml schema structure so that maven know what he's doing (4.0.0)
				- packaging (jar)
			convention: 
				- put files inside [/src/main/java/]HelloWorld.java (maven is going to compile any class underneath this directory)
				- put test files inside /test/main/java/[project package]/HelloWorldTest.java
			commands:
				- mvn clean
				- mvn compile (after you compile you get a "target" directory)
				- mvn archetype:generate
		
		from maven.apache.org
			1. Build the Project: mvn package
			2. You may test the newly compiled and packaged JAR with the following command:
			java -cp target/my-app-1.0-SNAPSHOT.jar com.mycompany.app.App
	2. Maven Structure
	
	
	
---
Copyright &copy; 2023 abderrahman.
</xmp>

<script src="../javascript/StrapDown.js"></script>
</html>
